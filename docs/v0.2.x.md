# âœ¨ Interactive Polish â€” v0.2.x Milestone

This guide outlines the design and implementation strategy for introducing interactive user experiences in `cargo-quickstart`. The goal is to support multiple modes (wizard, TUI, manual), enhance user onboarding, and improve usability.

---

## ðŸŽ¯ Objectives

- Provide three distinct UX modes for end-users:
  - **Wizard Mode (default)**: Linear, prompt-based setup (like `cargo-wizard`)
  - **TUI Mode (`--interactive`)**: Fullscreen terminal UI (like `crates-tui`)
  - **Manual Mode (`--manual`)**: Scriptable, no prompt mode for automation
- Use feature flags to conditionally compile each mode
- Provide clean CLI argument parsing for selecting a mode
- Begin separation of logic into modular files

---

## ðŸ“¦ Feature Flag Setup (`Cargo.toml`)

```toml
[features]
default = ["wizard"]
wizard = ["inquire"]
tui = ["ratatui", "crossterm", "tui-input"]
manual = []  # no dependencies

with-ui = ["console", "indicatif"]
with-color-eyre = ["color-eyre"]
with-time = ["chrono"]
```

Use `#[cfg(feature = "...")]` in code to selectively compile modules.

---

## ðŸ”§ CLI Argument Parsing

Use `clap` to define mutually exclusive flags for UX mode selection:

```rust
#[derive(clap::Parser)]
pub struct Args {
    /// Run in manual mode (no prompts, CI-friendly)
    #[arg(long)]
    manual: bool,

    /// Run in fullscreen interactive TUI mode
    #[arg(long)]
    interactive: bool,
}
```

---

## ðŸ§© Runtime Mode Selection

In `main.rs`, dispatch based on args:

```rust
mod mode;

fn main() -> Result<(), CliError> {
    let args = Args::parse();

    match args {
        Args { manual: true, .. } => mode::manual::run(args),
        Args { interactive: true, .. } => mode::tui::run(args),
        _ => mode::wizard::run(args),
    }
}
```

---

## ðŸ“ File Structure

```text
src/
  mode/
    mod.rs
    manual.rs
    wizard.rs
    tui.rs
```

Each module contains a `run(args)` function to handle its flow.

---

## ðŸ§ª Wizard Mode Implementation

- Use `inquire::Text`, `Select`, `Confirm` prompts
- Create reusable prompt functions in `ui/prompts.rs`
- Store results in a `QuickstartConfig` struct

```rust
pub fn prompt_project_name() -> Result<String> {
    inquire::Text::new("Project name")
        .with_help_message("The name of your Rust project")
        .prompt()
}
```

---

## ðŸ–¥ï¸ TUI Mode (MVP)
---

## ðŸ§± `quickstart-tui` Crate Setup

**Path:** `crates/quickstart-tui`

This crate handles all fullscreen TUI logic using `ratatui` and `crossterm`, gated via the `with-tui` feature.

- Public API: `pub fn launch_tui(args: &Args) -> Result<()>` in `crates/quickstart-tui/src/lib.rs`
- Called from `crates/quickstart-cli/src/main.rs` if `--interactive` and `--features tui` are passed

### ðŸ“ File Layout

```text
crates/
  quickstart-tui/
    src/
      lib.rs
      layout.rs      # rendering components
      events.rs      # input/event loop
      app_state.rs   # state management
```

### ðŸ“¦ Integration

- CLI dispatch occurs in `crates/quickstart-cli/src/main.rs`:
  ```rust
  #[cfg(feature = "tui")]
  Args { interactive: true, .. } => quickstart_tui::launch_tui(&args),
  ```

- Feature gated in `crates/quickstart-cli/Cargo.toml`:
  ```toml
  [features]
  tui = ["quickstart-tui"]
  ```

### ðŸ§ª Testing

- TUI test stub can be a no-op, verifying `quickstart-tui` compiles and links

---

## ðŸ§± `quickstart-tui` Crate Setup

The `quickstart-tui` crate encapsulates all logic for the fullscreen terminal UI. This crate is part of the workspace and is conditionally included using the `with-tui` feature flag in `quickstart-cli`.

### ðŸ“ File Layout

```text
crates/
  quickstart-tui/
    src/
      lib.rs
      layout.rs      # rendering components
      events.rs      # input/event loop
      app_state.rs   # state management
```

### ðŸ“¦ Cargo.toml (`quickstart-tui`)

```toml
[package]
name = "quickstart-tui"
version = "0.2.0"
edition = "2021"

[lib]
path = "src/lib.rs"

[dependencies]
quickstart-lib = { path = "../quickstart-lib" }
ratatui = { version = "0.26", default-features = false }
crossterm = { version = "0.27", default-features = false, features = ["event-stream", "cursor", "terminal", "style"] }
color-eyre = { version = "0.6", optional = true }

[features]
default = []
with-color-eyre = ["color-eyre"]
```

### ðŸ”Œ Integration in `quickstart-cli`

In `quickstart-cli/Cargo.toml`:

```toml
[features]
tui = ["quickstart-tui"]

[dependencies]
quickstart-tui = { path = "../quickstart-tui", optional = true }
```

In `main.rs` (feature-gated):

```rust
#[cfg(feature = "tui")]
fn run_tui(args: &Args) -> Result<()> {
    quickstart_tui::launch_tui(args)
}
```

### ðŸŽ¯ Launch API

The crate exposes a single public function:

```rust
pub fn launch_tui(args: &Args) -> Result<()> {
    // initialize terminal, app loop, handle shutdown
}
```

This makes it composable and safely callable from `main.rs` when compiled with the TUI feature.

### ðŸš§ Build Constraints

- TUI should only build if the `tui` feature is enabled.
- `ratatui` and `crossterm` are isolated in the crate.
- No CLI logic leaks from `quickstart-cli` into the TUI crate.

### ðŸ§ª TUI Stub for Now

For MVP:
- Just display the project name input field
- Accept input and confirmation key
- Print resulting config to terminal


- Use `ratatui::Terminal` and `crossterm` event handling
- Scaffold basic input form with project name and type
- Build app loop similar to `crates-tui`
- For now: one-screen layout with input + confirm

---

## ðŸ§ª Manual Mode

- Parse values directly from `args`
- Populate a `QuickstartConfig` without any prompts
- Example:

```rust
fn run(args: Args) -> Result<()> {
    let config = QuickstartConfig::from_args(args)?;
    apply_template(config)
}
```

---

## âœ… Checklist

- [x] Set up mode modules
- [x] Add `clap` arguments for mode selection
- [x] Implement Wizard Mode with `inquire` (stubbed)
- [x] Scaffold TUI Mode layout (stubbed)
- [x] Implement Manual Mode CLI parsing (stubbed)
- [x] Add feature flags for UI dependency control

---

**Target Version:** v0.2.x
**Maintained by:** sm-moshi

> **Current Status:** Mode modules and config groundwork are now committed. Implementation of full mode logic and TUI integration is next.